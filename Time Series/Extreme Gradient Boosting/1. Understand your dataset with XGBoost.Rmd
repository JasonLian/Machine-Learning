---
title: "Understand your dataset with XGBoost"
author: "Lian"
date: "2017年3月23日"
output:
  html_document:
    toc: true
    toc_depth: 6
    number_sections: false
    toc_float:
      collapsed: false
      smooth_scroll: false
    theme: readable
    highlight: tango
    code_folding: show
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Reference**:

- [Understand your dataset with XGBoost](https://cran.r-project.org/web/packages/xgboost/vignettes/discoverYourData.html)

### 0. Load Packages
```{r, message=FALSE, warning=FALSE}
library(data.table)
library(xgboost)
library(Matrix)
if (!require('vcd')) install.packages('vcd')
# VCD package is used for one of its embedded dataset only
```


### 1. An Quick Example in R
```{r}
# load data
data(agaricus.train, package='xgboost')
data(agaricus.test, package='xgboost')
train <- agaricus.train
test <- agaricus.test
# fit model
bst <- xgboost(data = train$data, label = train$label, max.depth = 2, eta = 1, nround = 2,
               nthread = 2, objective = "binary:logistic")
# predict
pred <- predict(bst, test$data)
```

### 2. Preparation of the dataset
**Xgboost manages only numeric vectors**
The first step is to load Arthritis dataset in memory and wrap it with data.table package.
```{r}
data(Arthritis)
df <- data.table(Arthritis, keep.rownames = F)
head(df)
str(df)
```

For many machine learning algorithms, using correlated features is not a good idea. It may sometimes make prediction less accurate, and most of the time make interpretation of the model almost impossible. GLM, for instance, assumes that the features are uncorrelated.

Fortunately, **decision tree algorithms (including boosted trees) are very robust to these features**. Therefore we have nothing to do to manage this situation.

```{r}
head(df[, AgeDiscret := as.factor(round(Age/10,0))])
head(df[,AgeCat:= as.factor(ifelse(Age > 30, "Old", "Young"))])
```

Cleaning data
```{r}
head(df[,ID:=NULL])
levels(df[,Treatment])
table(df[,Treatment])
```

Transform the categorical data to dummy variables

Column Improved is excluded because it will be our label column, the one we want to predict.

Formulae `Improved~.-1` used above means transform all categorical features but column Improved to binary values. **The -1 is here to remove the first column which is full of 1 (this column is generated by the conversion)**. For more information, you can type `?sparse.model.matrix` in the console.

```{r}
sparse_matrix <- sparse.model.matrix(Improved~.-1, data = df)
sparse_matrix@Dimnames[[2]]
head(sparse_matrix)
```

Create the output numeric vector (not as a sparse Matrix):

```{r}
output_vector = df[,Improved] == "Marked"
```

### 3. Build the Model
```{r}
bst <- xgboost(data = sparse_matrix, label = output_vector, max_depth = 4,
               eta = 1, nthread = 2, nrounds = 10,objective = "binary:logistic")
```

A model which fits too well may overfit (meaning it copy/paste too much the past, and won't be that good to predict the future).

Here you can see the numbers decrease until line 7 and then increase.

**It probably means we are overfitting**. To fix that I should reduce the number of rounds to nrounds = 4. I will let things like that because I don't really care for the purpose of this example :-)

### 4. Feature Importance
```{r}
importance <- xgb.importance(feature_names = colnames(sparse_matrix), model = bst)
head(importance)
```

`Gain` is the improvement in accuracy brought by a feature to the branches it is on. The idea is that before adding a new split on a feature X to the branch there was some wrongly classified elements, after adding the split on this feature, there are two new branches, and each of these branch is more accurate (one branch saying if your observation is on this branch then it should be classified as 1, and the other branch saying the exact opposite).

`Cover` measures the relative quantity of observations concerned by a feature.

`Frequency` is a simpler way to measure the Gain. It just counts the number of times a feature is used in all generated trees. You should not use it (unless you know why you want to use it).

**Improvement in the interpretability of feature importance data.table**

**We can go deeper in the analysis of the model**. In the data.table above, we have discovered which features counts to predict if the illness will go or not. But we don't yet know the role of these features. For instance, one of the question we may want to answer would be: **does receiving a placebo treatment helps to recover from the illness?**

One simple solution is to count the co-occurrences of a feature and a class of the classification.

For that purpose we will execute the same function as above but using two more parameters, `data` and `label`.

```{r}
importanceRaw <- xgb.importance(feature_names = colnames(sparse_matrix), model = bst, data = sparse_matrix, label = output_vector)

# Cleaning for better display
importanceClean <- importanceRaw[,`:=`(Cover=NULL, Frequency=NULL)]

head(importanceClean)
```

First thing you notice is the new column `Split`. It is the split applied to the feature on a branch of one of the tree. Each split is present, therefore a feature can appear several times in this table. Here we can see the feature Age is used several times with different splits.

How the split is applied to count the co-occurrences? It is always <. For instance, in the second line, we measure the number of persons under 61.5 years with the illness gone after the treatment.

The two other new columns are RealCover and RealCover %. In the first column it measures the number of observations in the dataset where the split is respected and the label marked as 1. The second column is the percentage of the whole population that RealCover represents.

Therefore, according to our findings, getting a placebo doesn't seem to help but being younger than 61 years may help (seems logic).

**Plotting the feature importance**
```{r}
xgb.plot.importance(importance_matrix = importance)
```

Feature have automatically been divided in 2 clusters: the interesting features… and the others.

Depending of the dataset and the learning parameters you may have more than two clusters. Default value is to limit them to 10, but you can increase this limit. Look at the function documentation for more information.

According to the plot above, the most important features in this dataset to predict if the treatment will work are :

- the Age ;
- having received a placebo or not ;
- the sex is third but already included in the not interesting features group ;
- then we see our generated features (AgeDiscret). We can see that their contribution is very low.

**Do these results make sense?**

Let's check some Chi2 between each of these features and the label. **Higher Chi2 means better correlation**.

```{r}
c2 <- chisq.test(df$Age, output_vector)
print(c2)
c2 <- chisq.test(df$AgeDiscret, output_vector)
print(c2)
c2 <- chisq.test(df$AgeCat, output_vector)
print(c2)
```

### 5. Conclusion
As you can see, in general destroying information by simplifying it won't improve your model. Chi2 just demonstrates that.

But in more complex cases, creating a new feature based on existing one which makes link with the outcome more obvious may help the algorithm and improve the model.

The case studied here is not enough complex to show that. Check Kaggle website for some challenging datasets. However it's almost always worse when you add some arbitrary rules.

Moreover, you can notice that **even if we have added some not useful new features highly correlated with other features, the boosting tree algorithm have been able to choose the best one**, which in this case is the Age.

**Linear model may not be that smart in this scenario**

### 6. What about Random Forests !!!
As you may know, Random Forests algorithm is cousin with boosting and both are part of the ensemble learning family.

**Both trains several decision trees for one dataset. The main difference is that in Random Forests™, trees are independent and in boosting, the tree N+1 focus its learning on the loss (<=> what has not been well modeled by the tree N).**

**This difference have an impact on a corner case in feature importance analysis: the correlated features.**

- Imagine two features perfectly correlated, feature A and feature B. For one specific tree, if the algorithm needs one of them, it will choose randomly (true in both boosting and Random Forests).

- However, **in Random Forests this random choice will be done for each tree, because each tree is independent from the others**. Therefore, approximatively, depending of your parameters, 50% of the trees will choose feature A and the other 50% will choose feature B. **So the importance of the information contained in A and B (which is the same, because they are perfectly correlated) is diluted in A and B**. So you won't easily know this information is important to predict what you want to predict! It is even worse when you have 10 correlated features.

**In boosting, when a specific link between feature and outcome have been learned by the algorithm, it will try to not refocus on it** (in theory it is what happens, reality is not always that simple). **Therefore, all the importance will be on feature A or on feature B (but not both). You will know that one feature have an important role in the link between the observations and the label. It is still up to you to search for the correlated features to the one detected as important if you need to know all of them.**

If you want to try Random Forests algorithm, you can tweak Xgboost parameters!

For instance, to compute a model with 1000 trees, with a 0.5 factor on sampling rows and columns:

```{r}
data(agaricus.train, package='xgboost')
data(agaricus.test, package='xgboost')
train <- agaricus.train
test <- agaricus.test

#Random Forest - 1000 trees
bst <- xgboost(data = train$data, label = train$label, max_depth = 4, num_parallel_tree = 1000, subsample = 0.5, colsample_bytree =0.5, nrounds = 1, objective = "binary:logistic")

#Boosting - 3 rounds
bst <- xgboost(data = train$data, label = train$label, max_depth = 4, nrounds = 3, objective = "binary:logistic")
```

Note that the parameter round is set to 1.


